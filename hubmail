#!/usr/bin/env python3
"""hubmail: a tool to export GitHub issues and pull requests as email messages
"""
# SPDX-License-Identifier: LGPL-2.1-or-later

import sys
import os
import email.utils as eu
from time import time, gmtime, asctime
import textwrap
import itertools
import re
import argparse
import asyncio

import aiohttp
from dateutil.parser import isoparse

try:
    from dotenv import load_dotenv
except ModuleNotFoundError:
    pass

def fatal(*args, **kwargs):
    print(*args, **kwargs, file=sys.stderr)
    sys.exit(1)


class Hubmail:
    NULL_ACTOR = {
        "login": "ghost",
        "name": "ghost",
        "email": "",
        "emailOrNull": ""
    }
    QUERY_FILE_NAME = "queries.graphql"

    def __init__(self, arguments):
        self.type = arguments.subcommand
        self.user = arguments.user
        self.repo = arguments.repo
        self.comments = arguments.comments
        self.wrap = arguments.wrap

        try:
            self.number = arguments.number
        except AttributeError:
            pass
        try:
            self.threads = arguments.threads
        except AttributeError:
            pass

        self.total_threads = 0
        try:
            with open(self.QUERY_FILE_NAME, "r") as queryFile:
                self.query = queryFile.read()
        except OSError as e:
            fatal(f"Could not open {self.QUERY_FILE_NAME} for reading")

    async def _run_query(self, opname, variables):
        if not self.session:
            fatal("No session initialized")

        async with self.session.post(
            "https://api.github.com/graphql",
            json={
                "query": self.query,
                "variables": variables,
                "operationName": opname
            },
            headers={"Authorization": f"Bearer {self.token}"}
        ) as resp:
            assert resp.status == 200
            result = await resp.json()
            assert "errors" not in result, result["errors"]
            return result

    async def _get_thread(self, thread_type, user, repo, number):
        # thread_type is either "issue" or "pullRequest"
        query = thread_type[0].upper() + thread_type[1:]
        variables = {"user": user, "repo": repo, "number": number}
        result = ((await self._run_query(query, variables))
                  ["data"]["repository"][thread_type])
        assert result is not None
        return result

    async def _get_threads(self, threads_type, user, repo):
        # threads_type is either "issues" or "pullRequests"
        query = threads_type[0].upper() + threads_type[1:]
        variables = {
            "user": user, "repo": repo,
            "numThreads": (20 if self.threads is None or self.threads >= 20
                           else self.threads),
            "cursor": None
        }
        while True:
            ## IssueConnection! | PullRequestConnection!
            result = ((await self._run_query(query, variables))
                           ["data"]["repository"][threads_type])
            self.total_threads += len(result["nodes"])
            if self.threads is None or self.total_threads <= self.threads:
                yield result["nodes"] or []
            else:
                # Remove the excess threads
                yield result["nodes"][:-(self.total_threads - self.threads)]
                break
            variables["cursor"] = result["pageInfo"]["endCursor"]
            if not variables["cursor"]:
                break

    async def _get_comments(self, id):
        variables = {
            "id": id,
            "numComments": (20 if self.comments is None or self.comments >= 20
                            else self.comments),
            "cursor": None
        }
        total_comments = 0
        while True:
            ## IssueCommentConnection!
            result = ((await self._run_query("Comments", variables))
                           ["data"]["node"]["comments"])
            total_comments += len(result["nodes"])
            if self.comments is None or total_comments <= self.comments:
                yield result["nodes"] or []
            else:
                # Remove the excess comments
                yield result["nodes"][:-(total_comments - self.comments)]
                break
            # Get new cursor; break if end of comments reached
            variables["cursor"] = result["pageInfo"]["endCursor"]
            if not variables["cursor"]:
                break

    def _format_email(self, name, address, timestamp, subject, body, heading,
                     message_id=None, in_reply_to=None, references=None):
        if references is None and in_reply_to is not None:
            references = [in_reply_to]

        body = body.replace("\r\n", "\n")

        try:
            cols = int(self.wrap)
        except (ValueError, TypeError):
            cols = 0
        if cols > 0:
            body = "\n".join(
                textwrap.fill(
                    line, cols, expand_tabs=False, replace_whitespace=False,
                    break_long_words=False, break_on_hyphens=False,
                    subsequent_indent=(
                        "> " if line.startswith("> ")
                        else ">" if line.startswith(">")
                        else ""))
                for line in body.splitlines())

        # Replace "From" at the beginning of a line with ">From";
        # include any quoting so that this process is reversible.
        body = re.sub(r"^([> ]*)From", r">\1From", body, flags=re.MULTILINE)

        return (
            textwrap.dedent(f"""\
                From nobody@localhost {asctime(gmtime(time()))}
                From: {eu.formataddr((name, address))}
                Date: {eu.format_datetime(timestamp)}
                Subject: {subject}
                Content-Type: text/plain; charset=UTF-8
                """)
            + (f"Message-ID: <{message_id}>\n" if message_id else "")
            + (f"In-Reply-To: <{in_reply_to}>\n" if in_reply_to else "")
            + (f"References: <{', '.join(references)}>\n" if references else "")
            + "\n" + body)

    async def _format_issue(self, user, repo, issue):
        number = issue["number"]
        author = issue["author"] or self.NULL_ACTOR
        assert number and author
        result = self._format_email(
            author.get("name") or author.get("login"), author.get("email") or
            author.get("emailOrNull") or "", isoparse(issue["createdAt"]),
            issue["title"], issue["body"], f"{user}/{repo}#{number}",
            f"{user}/{repo}/issues/{number}@github.com")
        if self.comments == 0:
            return result
        return result + "\n\n".join([i async for i in self._format_comments(
            issue["id"], f"Re: {issue['title']}",
            (user, repo, "issues", str(number)))])

    async def format_issue(self, user, repo, number):
        issue = await self._get_thread("issue", user, repo, number)
        return await self._format_issue(user, repo, number, issue)

    async def _format_pull(self, user, repo, pull):
        number = pull["number"]
        assert number
        async with self.session.get(f"{pull['url']}.patch") as resp:
            assert resp.status == 200
            thread_info = (user, repo, "pull", str(number))
            result = re.sub(
                r"(\nSubject: .*\n)", r"\1"
                + f"Message-ID: <{'/'.join(thread_info)}@github.com>\n",
                await resp.text())
        if self.comments == 0:
            return result
        return result + "\n\n".join([i async for i in self._format_comments(
            pull["id"], f"Re: {pull['title']}", thread_info)])

    async def format_pull(self, user, repo, number):
        ## PullRequest!
        pull = await self._get_thread("pullRequest", user, repo, number)
        return await self._format_pull(pull)

    async def _format_issues(self, user, repo):
        ## [Issue]!
        async for issues in self._get_threads("issues", user, repo):
            for issue in issues:
                yield await self._format_issue(user, repo, issue)

    async def format_issues(self, user, repo):
        return "\n\n".join([i async for i in self._format_issues(user, repo)])

    async def _format_pulls(self, user, repo):
        ## [PullRequest]!
        async for pulls in self._get_threads("pullRequests", user, repo):
            for pull in pulls:
                yield await self._format_pull(user, repo, pull)

    async def format_pulls(self, user, repo):
        return "\n\n".join([i async for i in self._format_pulls(user, repo)])

    async def _format_comments(self, id, subject, thread_info):
        user, repo, _, number = thread_info
        thread_name = f"{user}/{repo}#{number}"
        ## [IssueComment]!
        async for comments in self._get_comments(id):
            result = ""
            orig_message_id = f"{'/'.join(thread_info)}@github.com"
            for comment in comments:
                ## {login: String!, name?: String, email?: String!, emailOrNull?: String}
                author = comment["author"] or self.NULL_ACTOR
                message_id = f"{'/'.join(thread_info)}/c{comment['databaseId']}@github.com"
                result += "\n\n" + self._format_email(
                    author.get("name") or author.get("login"),
                    author.get("email") or author.get("emailOrNull") or "",
                    isoparse(comment["createdAt"]), subject, comment["body"],
                    thread_name, message_id, orig_message_id)
            yield result

    async def main(self):
        try:
            load_dotenv()
        except NameError:
            pass
        self.token = os.getenv("HUBMAIL_TOKEN")
        if not self.token:
            fatal("No API token found. Have you set the HUBMAIL_TOKEN " +
                   "environment variable?")

        async with aiohttp.ClientSession() as self.session:
            if self.type == "issue":
                print(await self.format_issue(
                    self.user, self.repo, self.number))
            elif self.type == "pull":
                print(await self.format_pull(
                    self.user, self.repo, self.number))
            elif self.type == "issues":
                print(await self.format_issues(self.user, self.repo))
            elif self.type == "pulls":
                print(await self.format_pulls(self.user, self.repo))
            else:
                fatal(f"Subcommand {self.type} not yet implemented")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description=textwrap.dedent(f"""\
            Export GitHub issues and pull requests as email messages
            in mbox format (RFC 4155).
            """))
    subparsers = parser.add_subparsers(
        title="subcommands", dest="subcommand", required=True)
    parent_parser = argparse.ArgumentParser(add_help=False)
    parent_parser.add_argument(
        "user", metavar="USER",
        help="The username of the owner of the repository")
    parent_parser.add_argument(
        "repo", metavar="REPO",
        help="The name of the repository")
    parent_parser.add_argument(
        "-c", "--comments", metavar="N", type=int, nargs='?', default=0,
        const=None,
        help=textwrap.dedent("""\
            Include the first %(metavar)s comments
            [default: all comments if -c provided]
            """))
    parent_parser.add_argument(
        "-w", "--wrap", metavar="COLS", type=int, nargs='?', const=72,
        help=textwrap.dedent("""\
            Wrap each line of text to %(metavar)s columns
            [default: 72 if -w provided]
            """))

    issue_parser = subparsers.add_parser(
        "issue", parents=[parent_parser],
        description="Export one issue in mbox format")
    pull_parser = subparsers.add_parser(
        "pull", parents=[parent_parser],
        description="Export one pull request in mbox format")

    issue_parser.add_argument(
        "number", metavar="NUMBER", type=int,
        help="The number of the issue")
    pull_parser.add_argument(
        "number", metavar="NUMBER", type=int,
        help="The number of the pull request")

    repo_parent_parser = argparse.ArgumentParser(
        add_help=False, parents=[parent_parser])

    issues_parser = subparsers.add_parser(
        "issues", parents=[repo_parent_parser],
        description="Export issues from a repository in mbox format")
    pulls_parser = subparsers.add_parser(
        "pulls", parents=[repo_parent_parser],
        description="Export pull requests from a repository in mbox format")

    issues_parser.add_argument(
        "-t", "--threads", metavar="N", type=int,
        help=textwrap.dedent("""\
            Include the first %(metavar)s threads [default: all threads]
            """))
    pulls_parser.add_argument(
        "-t", "--threads", metavar="N", type=int,
        help=textwrap.dedent("""\
            Include the first %(metavar)s threads [default: all threads]
            """))

    asyncio.run(Hubmail(parser.parse_args()).main())
