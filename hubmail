#!/usr/bin/env python3
"""hubmail: a tool to export GitHub issues and pull requests as email messages
"""
# SPDX-License-Identifier: LGPL-2.1-or-later

import sys
import os
from email.policy import default as default_policy
from email.message import EmailMessage
from email.headerregistry import Address
from email.parser import HeaderParser
from time import time, gmtime, asctime
import textwrap
import itertools
import re
import argparse
import asyncio

import aiohttp
from dateutil.parser import isoparse

try:
    from dotenv import load_dotenv
except ModuleNotFoundError:
    pass

def fatal(*args, **kwargs):
    print(*args, **kwargs, file=sys.stderr)
    sys.exit(1)


class Hubmail:
    NULL_ACTOR = {
        "login": "ghost",
        "name": "ghost",
        "email": "",
        "emailOrNull": ""
    }
    QUERY_FILE_NAME = "queries.graphql"

    def __init__(self, arguments):
        self.type = arguments.subcommand
        self.user = arguments.user
        self.repo = arguments.repo
        self.comments = arguments.comments
        self.wrap = arguments.wrap

        try:
            self.number = arguments.number
        except AttributeError:
            pass
        try:
            self.threads = arguments.threads
        except AttributeError:
            pass

        self.total_threads = 0

        self.policy = default_policy.clone(
            max_line_length = self.wrap,
            raise_on_defect = True,
        )
        self.patch_policy = default_policy.clone(
            max_line_length = None,
            refold_source = "none",
            raise_on_defect = True,
        )

        try:
            with open(self.QUERY_FILE_NAME, "r") as queryFile:
                self.query = queryFile.read()
        except OSError as e:
            fatal(f"Could not open {self.QUERY_FILE_NAME} for reading")

    async def _run_query(self, opname, variables):
        if not self.session:
            fatal("No session initialized")

        async with self.session.post(
            "https://api.github.com/graphql",
            json={
                "query": self.query,
                "variables": variables,
                "operationName": opname
            },
            headers={"Authorization": f"Bearer {self.token}"}
        ) as resp:
            assert resp.status == 200
            result = await resp.json()
            assert "errors" not in result, result["errors"]
            return result

    async def _get_thread(self, thread_type, user, repo, number):
        # thread_type is either "issue" or "pullRequest"
        query = thread_type[0].upper() + thread_type[1:]
        variables = {"user": user, "repo": repo, "number": number}
        result = ((await self._run_query(query, variables))
                  ["data"]["repository"][thread_type])
        assert result is not None
        return result

    async def _get_threads(self, threads_type, user, repo):
        # threads_type is either "issues" or "pullRequests"
        query = threads_type[0].upper() + threads_type[1:]
        variables = {
            "user": user, "repo": repo,
            "numThreads": (20 if self.threads is None or self.threads >= 20
                           else self.threads),
            "cursor": None
        }
        while True:
            ## IssueConnection! | PullRequestConnection!
            result = ((await self._run_query(query, variables))
                           ["data"]["repository"][threads_type])
            self.total_threads += len(result["nodes"])
            if self.threads is None or self.total_threads <= self.threads:
                yield result["nodes"] or []
            else:
                # Remove the excess threads
                yield result["nodes"][:-(self.total_threads - self.threads)]
                break
            variables["cursor"] = result["pageInfo"]["endCursor"]
            if not variables["cursor"]:
                break

    async def _get_comments(self, id):
        variables = {
            "id": id,
            "numComments": (20 if self.comments is None or self.comments >= 20
                            else self.comments),
            "cursor": None
        }
        total_comments = 0
        while True:
            ## IssueCommentConnection!
            result = ((await self._run_query("Comments", variables))
                           ["data"]["node"]["comments"])
            total_comments += len(result["nodes"])
            if self.comments is None or total_comments <= self.comments:
                yield result["nodes"] or []
            else:
                # Remove the excess comments
                yield result["nodes"][:-(total_comments - self.comments)]
                break
            # Get new cursor; break if end of comments reached
            variables["cursor"] = result["pageInfo"]["endCursor"]
            if not variables["cursor"]:
                break

    def _format_email(self, name, address, timestamp, subject, body,
                      message_id, in_reply_to="", references=""):
        body = body.replace("\r\n", "\n")

        try:
            cols = int(self.wrap)
        except (ValueError, TypeError):
            cols = 0
        if cols > 0:
            body = "\n".join(
                textwrap.fill(
                    line, cols, expand_tabs=False, replace_whitespace=False,
                    break_long_words=False, break_on_hyphens=False,
                    subsequent_indent=(
                        "> " if line.startswith("> ")
                        else ">" if line.startswith(">")
                        else ""))
                for line in body.splitlines())

        # Replace "From" at the beginning of a line with ">From"
        # (see https://www.jwz.org/doc/content-length.html)
        body = re.sub(r"^From", r">From", body, flags=re.MULTILINE)

        msg = EmailMessage(policy=self.policy)
        msg.set_content(body)

        try:
            msg["From"] = Address(name, addr_spec=address)
        except IndexError:
            msg["From"] = Address(name)
        msg["Date"] = timestamp
        msg["Subject"] = subject
        if message_id:
            msg["Message-ID"] = message_id
        if in_reply_to:
            msg["In-Reply-To"] = in_reply_to

        if references and in_reply_to:
            msg["References"] = f"{references} {in_reply_to}"
        elif references:
            msg["References"] = references
        elif in_reply_to:
            msg["References"] = in_reply_to

        # For some reason as_string does not include the unixfrom line
        # and as_bytes uses the quoted-printable encoding despite purportedly
        # supporting native Unicode.
        return msg.as_bytes(policy=self.policy, unixfrom=True).decode()

    async def _format_issue(self, user, repo, issue):
        number = issue["number"]
        author = issue["author"] or self.NULL_ACTOR
        assert number and author
        result = self._format_email(
            author.get("name") or author.get("login"), author.get("email") or
            author.get("emailOrNull") or "", isoparse(issue["createdAt"]),
            issue["title"], issue["body"],
            f"<{user}/{repo}/issues/{number}@github.com>")
        if self.comments == 0:
            return result
        return result + "\n\n".join([i async for i in self._format_comments(
            issue["id"], f"Re: {issue['title']}",
            (user, repo, "issues", str(number)))])

    async def format_issue(self, user, repo, number):
        issue = await self._get_thread("issue", user, repo, number)
        return await self._format_issue(user, repo, issue)

    async def _format_pull(self, user, repo, pull):
        number = pull["number"]
        author = pull["author"] or self.NULL_ACTOR
        assert number and author
        thread_info = (user, repo, "pull", str(number))
        message_id = f"<{'/'.join(thread_info)}@github.com>"
        result = self._format_email(
            author.get("name") or author.get("login"), author.get("email") or
            author.get("emailOrNull") or "", isoparse(pull["createdAt"]),
            pull["title"], pull["body"], message_id)

        # Get pull request patches
        async with self.session.get(f"{pull['url']}.patch") as resp:
            assert resp.status == 200
            for rawtext in re.split(
                    r"^From ", await resp.text(), flags=re.MULTILINE)[1:]:

                unixfrom, text = rawtext.split('\n', 1)
                commit_sha = unixfrom.split(' ', 1)[0]

                # Keep headers separate from body so that patch is not mangled
                # (e.g. if patch contains CRLF, don't convert to LF)
                headers, body = text.split('\n\n', 1)
                msg = HeaderParser(policy=self.patch_policy).parsestr(headers)
                msg["Message-ID"] = (
                    f"<{'/'.join(thread_info)}/{commit_sha}@github.com>")
                msg["In-Reply-To"] = message_id
                msg["References"] = message_id
                result += (
                    '\n' + "From " + unixfrom + '\n'
                    + msg.as_string(policy=self.policy) + body)

        if self.comments == 0:
            return result
        return result + "\n".join([i async for i in self._format_comments(
            pull["id"], f"Re: {pull['title']}", thread_info)])

    async def format_pull(self, user, repo, number):
        ## PullRequest!
        pull = await self._get_thread("pullRequest", user, repo, number)
        return await self._format_pull(user, repo, pull)

    async def _format_issues(self, user, repo):
        ## [Issue]!
        async for issues in self._get_threads("issues", user, repo):
            for issue in issues:
                yield await self._format_issue(user, repo, issue)

    async def format_issues(self, user, repo):
        return "\n\n".join([i async for i in self._format_issues(user, repo)])

    async def _format_pulls(self, user, repo):
        ## [PullRequest]!
        async for pulls in self._get_threads("pullRequests", user, repo):
            for pull in pulls:
                yield await self._format_pull(user, repo, pull)

    async def format_pulls(self, user, repo):
        return "\n\n".join([i async for i in self._format_pulls(user, repo)])

    async def _format_comments(self, id, subject, thread_info):
        user, repo, _, number = thread_info
        ## [IssueComment]!
        async for comments in self._get_comments(id):
            result = ""
            orig_message_id = f"<{'/'.join(thread_info)}@github.com>"
            for comment in comments:
                ## {login: String!, name?: String, email?: String!, emailOrNull?: String}
                author = comment["author"] or self.NULL_ACTOR
                message_id = f"<{'/'.join(thread_info)}/c{comment['databaseId']}@github.com>"
                result += "\n\n" + self._format_email(
                    author.get("name") or author.get("login"),
                    author.get("email") or author.get("emailOrNull") or "",
                    isoparse(comment["createdAt"]), subject, comment["body"],
                    message_id, orig_message_id)
            yield result

    async def main(self):
        try:
            load_dotenv()
        except NameError:
            pass
        self.token = os.getenv("HUBMAIL_TOKEN")
        if not self.token:
            fatal("No API token found. Have you set the HUBMAIL_TOKEN " +
                   "environment variable?")

        async with aiohttp.ClientSession() as self.session:
            if self.type == "issue":
                print(await self.format_issue(
                    self.user, self.repo, self.number))
            elif self.type == "pull":
                print(await self.format_pull(
                    self.user, self.repo, self.number))
            elif self.type == "issues":
                print(await self.format_issues(self.user, self.repo))
            elif self.type == "pulls":
                print(await self.format_pulls(self.user, self.repo))
            else:
                fatal(f"Subcommand {self.type} not yet implemented")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description=textwrap.dedent(f"""\
            Export GitHub issues and pull requests as email messages
            in mbox format (RFC 4155).
            """))
    subparsers = parser.add_subparsers(
        title="subcommands", dest="subcommand", required=True)
    parent_parser = argparse.ArgumentParser(add_help=False)
    parent_parser.add_argument(
        "user", metavar="USER",
        help="The username of the owner of the repository")
    parent_parser.add_argument(
        "repo", metavar="REPO",
        help="The name of the repository")
    parent_parser.add_argument(
        "-c", "--comments", metavar="N", type=int, nargs='?', default=0,
        const=None,
        help=textwrap.dedent("""\
            Include the first %(metavar)s comments
            [default: all comments if -c provided]
            """))
    parent_parser.add_argument(
        "-w", "--wrap", metavar="COLS", type=int, nargs='?', const=72,
        help=textwrap.dedent("""\
            Wrap each line of text to %(metavar)s columns
            [default: 72 if -w provided]
            """))

    issue_parser = subparsers.add_parser(
        "issue", parents=[parent_parser],
        description="Export one issue in mbox format")
    pull_parser = subparsers.add_parser(
        "pull", parents=[parent_parser],
        description="Export one pull request in mbox format")

    issue_parser.add_argument(
        "number", metavar="NUMBER", type=int,
        help="The number of the issue")
    pull_parser.add_argument(
        "number", metavar="NUMBER", type=int,
        help="The number of the pull request")

    repo_parent_parser = argparse.ArgumentParser(
        add_help=False, parents=[parent_parser])

    issues_parser = subparsers.add_parser(
        "issues", parents=[repo_parent_parser],
        description="Export issues from a repository in mbox format")
    pulls_parser = subparsers.add_parser(
        "pulls", parents=[repo_parent_parser],
        description="Export pull requests from a repository in mbox format")

    issues_parser.add_argument(
        "-t", "--threads", metavar="N", type=int,
        help=textwrap.dedent("""\
            Include the first %(metavar)s threads [default: all threads]
            """))
    pulls_parser.add_argument(
        "-t", "--threads", metavar="N", type=int,
        help=textwrap.dedent("""\
            Include the first %(metavar)s threads [default: all threads]
            """))

    asyncio.run(Hubmail(parser.parse_args()).main())
